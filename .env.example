# ===========================================
# FLASK CONFIGURATION
# ===========================================
# Indica el entorno de ejecución: production | development | testing
FLASK_ENV=
# Puerto donde escucha la aplicación
FLASK_PORT=5000
# Nombre de la aplicación (visible en procesos)
APP_NAME=flask_app
# Se usa para acceso a endpoints de admin (poner manualmente y compartirlas con otros admins)
ADMIN_SECRET_KEY=

# Modo daemon:
# - False: para systemd (Type=simple) o ejecución en foreground
# - True: para ejecución en background sin systemd
GUNICORN_DAEMON=

# Validacion schemas: True / False
MA_ENABLED=

# ===========================================
# DATABASE
# ===========================================
# Habilita DB True / False
DB_ENABLED=False

# Datos de conexión a la base de datos
# mysql | postgresql
DB_TYPE=
DB_HOST=
DB_PORT=
DB_DATABASE=
DB_USER=
DB_PASSWORD=

# ===========================================
# SMTP / EMAIL
# ===========================================
# Habilita el servicio de Mail True / False
MAIL_ENABLED=False

# Servidor SMTP
MAIL_SERVER=
# Puerto SMTP
MAIL_PORT=

# Cifrado
# Dev: False | Prod: True
MAIL_USE_TLS=
MAIL_USE_SSL=

# Credenciales
# Dev: (vacío) | Prod: usuario y contraseña/API key
MAIL_USERNAME=
MAIL_PASSWORD=

# Remitente
# Dev: cualquiera | Prod: email verificado en tu proveedor
MAIL_DEFAULT_SENDER=

# Timeout en segundos
# Dev: (vacío) | Prod: 30-60
MAIL_TIMEOUT=

# Máximo emails por conexión
# Dev: (vacío) | Prod: según límites del proveedor
MAIL_MAX_EMAILS=

# Forzar ASCII en adjuntos
# Dev: False | Prod: True si hay problemas con caracteres especiales
MAIL_ASCII_ATTACHMENTS=

# ===========================================
# EXTERNAL SERVICES (opcional)
# ===========================================
# URL base de API externa sin trailing slash: https://api.example.com
EXTERNAL_API_URL_BASE=
# Timeout en segundos para requests externos
REQUEST_TIMEOUT=30

# ===========================================
# LOGGING
# ===========================================
# Define el nivel de alertamiento de la aplicación
# Niveles jerárquicos: DEBUG | INFO | WARNING | ERROR | CRITICAL
LOG_LEVEL=

# ===========================================
# GUNICORN - WORKERS
# ===========================================
# Número de workers (procesos independientes) para manejar requests
# Cada worker consume RAM adicional (~30-50MB por worker)
# Recomendado: (CPU cores * 2) + 1
# Ejemplo: servidor con 2 cores → 5 workers
# 
# MÍNIMO: 1 (solo desarrollo)
# ESCALA: +1 worker por cada núcleo de CPU adicional
#         Más workers = más RAM, más requests paralelos
#         Menos workers = menos RAM, posible cuello de botella
GUNICORN_WORKERS=3

# Tipo de worker según la necesidad:
# - sync: 1 request a la vez por worker, simple, para tareas CPU-bound
# - gthread: usa threads, ideal para I/O (consultas DB, APIs externas)
# - gevent: async, para alta concurrencia, WebSockets, SSE (miles de conexiones)
#
# MÍNIMO: sync (más simple, sin dependencias)
# ESCALA: sync → gthread → gevent (de menor a mayor concurrencia)
#         sync: ~3 req/seg por worker
#         gthread: ~50 req/seg por worker (con threads)
#         gevent: ~1000+ req/seg por worker (async)
GUNICORN_WORKER_CLASS=gthread

# Threads por worker (solo aplica para gthread)
# Capacidad total = workers × threads (ej: 3 × 4 = 12 requests simultáneos)
#
# MÍNIMO: 2
# ESCALA: +2 threads por cada 100 requests/segundo adicionales esperados
#         Más threads = más concurrencia, más uso de CPU
#         Máximo recomendado: 8-12 por worker (más causa overhead)
GUNICORN_THREADS=4

# Conexiones máximas por worker (solo aplica para gevent)
# Permite miles de conexiones simultáneas con bajo consumo de RAM
#
# MÍNIMO: 100
# ESCALA: según conexiones concurrentes esperadas
#         API pequeña: 100-500
#         API media: 500-1000
#         Alta concurrencia: 1000-10000
GUNICORN_WORKER_MAX_CONNECTIONS=1000

# ===========================================
# GUNICORN - TIMEOUTS
# ===========================================
# Tiempo máximo (segundos) para que un worker responda un request
# Si se excede, el worker es matado y reiniciado (previene bloqueos)
#
# MÍNIMO: 10 (APIs rápidas)
# ESCALA: según el request más lento de tu app
#         APIs simples: 10-30
#         Consultas DB pesadas: 30-60
#         Procesamiento archivos: 60-120
#         Nunca más de 300 (indica problema de diseño)
GUNICORN_TIMEOUT=30

# Tiempo de gracia (segundos) para terminar requests pendientes al reiniciar
# Durante shutdown, espera este tiempo antes de forzar el cierre
#
# MÍNIMO: igual a GUNICORN_TIMEOUT
# ESCALA: generalmente igual o mayor que timeout
#         Permite que requests en curso terminen durante deploys
GUNICORN_GRACEFUL_TIMEOUT=30

# Tiempo de espera (segundos) para conexiones keep-alive
# Mantiene la conexión TCP abierta esperando más requests del mismo cliente
#
# MÍNIMO: 2
# ESCALA: 2-5 segundos es óptimo para la mayoría
#         Más alto = más conexiones abiertas, más RAM
#         Si usas Nginx como proxy, este valor debe ser menor que el de Nginx
GUNICORN_KEEP_ALIVE=5

# ===========================================
# GUNICORN - WORKER LIFECYCLE
# ===========================================
# Requests máximos antes de reiniciar un worker automáticamente
# Previene memory leaks acumulados en aplicaciones de larga ejecución
#
# MÍNIMO: 500
# ESCALA: según estabilidad de tu app
#         App con memory leaks: 500-1000
#         App estable: 1000-5000
#         App muy estable: 5000-10000
#         0 = deshabilitado (no recomendado)
GUNICORN_MAX_REQUESTS=1000

# Variación aleatoria (0 a N) añadida a max_requests
# Evita que todos los workers se reinicien al mismo tiempo
# Ejemplo: con 1000 + jitter 100, workers se reinician entre 1000-1100 requests
#
# MÍNIMO: 50
# ESCALA: 10% de max_requests es buena regla
#         max_requests=1000 → jitter=100
#         max_requests=5000 → jitter=500
GUNICORN_MAX_REQUESTS_JITTER=100

# ===========================================
# CORS
# ===========================================
# Orígenes permitidos separados por coma
# Ejemplo: https://tudominio.com,https://admin.tudominio.com
# IMPORTANTE: No usar * en producción
CORS_ORIGINS=http://localhost:3000
# Métodos HTTP permitidos separados por coma
CORS_METHODS=GET,POST,PUT,DELETE
# Tiempo en segundos que el navegador cachea la respuesta preflight
CORS_MAX_AGE=3600

# ===========================================
# RATE LIMITING (opcional)
# ===========================================
# Límite de requests por cliente
# Formato: "100 per hour", "10 per minute"
RATE_LIMIT_DEFAULT=100 per hour
RATE_LIMIT_LOGIN=5 per minute

# ===========================================
# JWT (opcional)
# ===========================================
# Habilita el uso de JWT True / False
JWT_ENABLED=
# Generar con: python -c "import secrets; print(secrets.token_hex(32))"
JWT_SECRET_KEY=
# Tiempo de expiración del access token en segundos
JWT_ACCESS_TOKEN_EXPIRES=3600
# Tiempo de expiración del refresh token en segundos
JWT_REFRESH_TOKEN_EXPIRES=2592000

# ===========================================
# REDIS (opcional)
# ===========================================
REDIS_ENABLED=false
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=
REDIS_DB=0